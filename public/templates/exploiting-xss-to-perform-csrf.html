{% extends "base.html" %}{% block title %}Exploiting XSS to perform CSRF{%endblock%}
{% block content %}
        <h1 id="typing-effect" class="display-2 mb-4"></h1>
        <p>
            <b class="solution-title">Solution</b>
        </p>
        <p class="solution-text no-indent">
            In this lab, we will be exploiting a stored XSS vulnerability to execute a CSRF attack and change the email address of any user who views a specific blog post. The lab instructions state that the XSS vulnerability is present in the comment section of the blog posts. 
            We can access this lab by clicking <a class="fake-link" target="blank" href="https://portswigger.net/web-security/cross-site-scripting/exploiting/lab-perform-csrf">here</a>. 
        </p>
        <p class="solution-text no-indent">
            We are given the following credentials to login the website 'wiener:peter'. After successfully logging in, we can test the presence of XSS
            vulnerability by simply passing as a comment the following payload: &lt;script&gt;alert(1)&lt;/script&gt; and visiting the page back again.
        </p>
        <div class="fig-breath">
            <img class="fig-body" src="{{ url_for('static', filename='img/xss13-img1.png') }}">
        </div> 
        <p class="solution-text no-indent">
            After successfully confirming the presence of a stored XSS vulnerability, our next step is to explore how we can exploit it to modify the email of any visitor who accesses the blog. To begin, we should navigate to the My Account link located in the top-right corner of the page and examine the email change feature. With BurpSuite already open and running, we can proceed to capture the POST request for email modification. This request contains two parameters: the 'email' parameter and the 'csrf' parameter.
             The latter is an anti-csrf token that is unique to each user, making it challenging for us to escalate our XSS and execute our desired action.
        </p>
        <div class="fig-breath">
            <img class="fig-body" src="{{ url_for('static', filename='img/xss13-img2.png') }}">
        </div> 
        <p class="solution-text no-indent">
            Nevertheless, we can test different XSS payloads by attempting to only modify our email via the comment section with our
            csrf token. Although this will only change our own email, it is a useful test to identify the appropriate payload that can modify the email of any user who accesses the page. Once we have identified the right approach for our own account, the next step is to learn how
            to bypass or forge the csrf token parameter. One potential payload for achieving this is to include the following Javascript code:
        </p>
        <div class="shrink">
            <pre>
                <code id="text" class="hljs language-js">
                    fetch('/my-account/change-email', {
                        method: 'POST',
                        body: `csrf=OUR_TOKEN&email=hi@mom.com`,
                        headers: {
                          'Content-Type': 'application/x-www-form-urlencoded'
                        }
                      });
                </code>
            </pre>
        </div>         
        <div class="fig-breath">
            <img class="fig-body" src="{{ url_for('static', filename='img/xss13-img3.png') }}">
        </div> 
        <p class="solution-text no-indent">
            After sending the request, we can visit My Account again to check whether our email was changed. And ideed it was:
        </p>
        <div class="fig-breath">
            <img class="fig-body" src="{{ url_for('static', filename='img/xss13-img4.png') }}">
        </div> 
        <p class="solution-text no-indent">
            Now that we know how to exploit the vulnerability to change our own email, our next step is to bypass the csrf token to enable our script payload to change any user's email. We can observe that the csrf token is embedded in a hidden input element in the source code of the My Account page. Therefore, we need to extract this csrf token in order to bypass it when other users access the blog post containing our payload. Since each user has a unique and unguessable csrf token, we cannot predict or forge it. Instead, we can leverage the fetch method to capture the csrf token of the user who is visiting the blog page where we posted our payload. 
            Although the csrf token is unique and unguessable, its value is displayed on the My Account page of every user, allowing us to capture it in a GET request.
        </p>
        <div class="fig-breath">
            <img class="fig-body" src="{{ url_for('static', filename='img/xss13-img5.png') }}">
        </div> 
        <p class="solution-text no-indent">
            Our ideal payload needs to fetch the csrf hidden in the source page of the user. This can be achieved with the following script:
        </p>
        <div class="shrink">
            <pre>
                <code id="text" class="hljs language-js">
                    fetch('/my-account');
                        .then(response =&gt; response.text());
                        .then(text =&gt; {
                            const token = text.match(/name="csrf" value="(\w+)"/)[1];
                            return fetch('/my-account/change-email', {
                                method: 'POST',
                                body: `csrf=${token}&amp;email=hi@mom.io`,
                                headers: {
                                  'Content-Type': 'application/x-www-form-urlencoded'
                                }
                              });
                        });

                </code>
            </pre>
        </div> 
        <p class="solution-text no-indent">
            Here, we are capturing the response of the user's My Account page via a GET request and using regular expressions to extract the csrf token from the response. We then use this token to modify the email of the targeted user by injecting our initial payload. Finally, we wrap this payload between script tags and post it as a comment on a blog post to complete the lab.
        </p>
        <div class="fig-breath">
            <img class="fig-body" src="{{ url_for('static', filename='img/xss13-img6.png') }}">
        </div> 
        <p class="solution-text no-indent">
            Solving the lab!
        </p>
        <div class="fig-breath">
            <img class="fig-body" src="{{ url_for('static', filename='img/xss13-img7.png') }}">
        </div> 
        <a href="/labs">Go back</a>
{%endblock%}